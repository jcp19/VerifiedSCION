// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package slayers

import (
	"github.com/scionproto/scion/pkg/slayers/path"
	"github.com/scionproto/scion/verification/utils/slices"
)

type PathMemLoc uint8

const (
	New PathMemLoc = iota
	Pool
	Raw
)

pred (b *BaseLayer) Mem() {
	acc(b) &&
	slices.AbsSlice_Bytes(b.Contents, 0, len(b.Contents)) &&
	slices.AbsSlice_Bytes(b.Payload, 0, len(b.Payload))
}

pred (b *BaseLayer) LayerMem() {
	acc(b) && slices.AbsSlice_Bytes(b.Contents, 0, len(b.Contents))
}

pred (b *BaseLayer) PayloadMem() {
	acc(b) && slices.AbsSlice_Bytes(b.Payload, 0, len(b.Payload))
}

pred (s *SCION) Mem() {
		s.BaseLayer.Mem() &&
			acc(&s.Version) &&
			acc(&s.TrafficClass) &&
			acc(&s.FlowID) &&
			acc(&s.NextHdr) &&
			acc(&s.HdrLen) &&
			acc(&s.PayloadLen) &&
			acc(&s.PathType) &&
			acc(&s.DstAddrType) &&
			acc(&s.DstAddrLen) &&
			acc(&s.SrcAddrType) &&
			acc(&s.SrcAddrLen) &&
			acc(&s.DstIA) &&
			acc(&s.SrcIA) &&
			acc(&s.RawDstAddr) &&
			acc(&s.RawSrcAddr) &&
			slices.AbsSlice_Bytes(s.RawDstAddr, 0, len(s.RawDstAddr)) &&
			slices.AbsSlice_Bytes(s.RawSrcAddr, 0, len(s.RawSrcAddr)) &&

			acc(&s.Path) &&
			s.Path != nil &&
			s.Path.Mem() &&

			acc(&s.pathPool) &&
			(s.pathPool != nil ==>
				len(s.pathPool) < path.maxPathType &&
				(forall i int :: 0 <= i && i < len(s.pathPool) &&
					(s.getPathLoc() != Pool || i != int(s.PathType)) ==>
					s.pathPool[i].NonInitMem())) &&

			acc(&s.pathPoolRaw) &&
			s.pathPoolRaw != nil &&
			(s.getPathLoc() == Raw ==> s.pathPoolRaw.Mem()) &&
			(s.getPathLoc() != Raw ==> s.pathPoolRaw.NonInitMem()) &&

			// Well-formedness for values
			s.DstAddrLen >= 0 &&
			s.SrcAddrLen >= 0
}

pred (s *SCION) AddrHdrMem() {
		acc(&s.RawDstAddr) &&
		acc(&s.RawSrcAddr) &&
		acc(&s.DstAddrLen) &&
		acc(&s.SrcAddrLen) &&
		acc(&s.DstIA) &&
		acc(&s.SrcIA) &&
		slices.AbsSlice_Bytes(s.RawDstAddr, 0, len(s.RawDstAddr)) &&
		slices.AbsSlice_Bytes(s.RawSrcAddr, 0, len(s.RawSrcAddr)) &&
		s.DstAddrLen >= 0 &&
		s.SrcAddrLen >= 0
}

ghost
requires acc(s.Mem(), _)
pure func (s *SCION) getPathLoc() PathMemLoc

ghost
requires s.Mem()
ensures  s.getPathLoc() == l
func (s *SCION) setPathLoc(l PathMemLoc)

ghost
requires acc(&s.pathPool)
pure func (s *SCION) hasPathPool() bool {
	return s.pathPool != nil
}
