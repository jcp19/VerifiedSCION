// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package conn

import (
	"net"

	"github.com/scionproto/scion/verification/utils/slices"

	"golang.org/x/net/ipv4"
	"golang.org/x/net/ipv6"
)

/** Mem predicate definitions **/
pred (c *connUDPBase) Mem() {
	acc(c) &&
	c.conn.Mem() &&
	acc(c.Listen.Mem(), _) &&
	acc(c.Remote.Mem(), _)
}

// TODO: explain two params
pred (c *connUDPBase) MemWithoutConn(ipv4Conn *ipv4.PacketConn, ipv6Conn *ipv6.PacketConn) {
	((ipv4Conn != nil && ipv6Conn == nil) || (ipv6Conn != nil && ipv4Conn == nil)) &&
	acc(c) &&
	acc(c.Listen.Mem(), _) &&
	acc(c.Remote.Mem(), _)
}

pred (c *connUDPIPv4) Mem() {
	acc(&c.pconn) &&
	c.connUDPBase.MemWithoutConn(c.pconn, nil) &&
	c.pconn.Mem()
}

pred (c *Config) Mem() {
	acc(c) &&
	0 <= c.SendBufferSize &&
	0 <= c.ReceiveBufferSize
}

// TODO
// *connUDPIPv4 implements Conn
// TODO: spec udpconnbase
// TODO: lift methods from connUDPBase to its implementations

/** Lift methods in *connUDPBase to *connUDPIPv4 **/
trusted
preserves c.Mem()
preserves slices.AbsSlice_Bytes(b, 0, len(b))
ensures   err == nil ==> 0 <= n && n <= len(b)
ensures   err == nil ==> acc(addr.Mem(), _)
ensures   err != nil ==> err.ErrorMem()
func (c *connUDPIPv4) ReadFrom(b []byte) (n int, addr *net.UDPAddr, err error) {
// call impl
}

trusted
func (c *connUDPIPv4) Write(b []byte) (int, error) {
// call impl
}

trusted
func (c *connUDPIPv4) WriteTo(b []byte, dst *net.UDPAddr) (int, error) {
// call impl
}

trusted
func (c *connUDPIPv4) LocalAddr() *net.UDPAddr {
// call impl
}

trusted
func (c *connUDPIPv4) RemoteAddr() *net.UDPAddr {
// call impl
}

requires c.Mem()
ensures  err != nil ==> err.ErrorMem()
decreases
func (c *connUDPIPv4) Close() (err error) {
	unfold c.Mem()
	c.connUDPBase.Close()
}
/** End of Lift methods in *connUDPBase to *connUDPIPv4 **/

//TODO: redo everything for ipv6:
// *connUDPIPv6 implements Conn
// TODO: add post to readbatch in ipv6
// TODO: disable consistency checks here because of