// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package router

import (
	"net"
)

pred nonNilErr(e *error) {
	acc(e, _) && isComparable(*e) && *e != nil && (*e).ErrorMem()
}

pred MutexInvariant(d *DataPlane) {
	// access to the field 'mtx' ommited
	acc(&d.external)          &&
	acc(&d.linkTypes)         &&
	acc(&d.neighborIAs)       &&
	acc(&d.internal)          &&
	acc(&d.internalIP)        &&
	acc(&d.internalNextHops)  &&
	acc(&d.svc)               &&
	acc(&d.macFactory)        &&
	acc(&d.bfdSessions)       &&
	acc(&d.localIA)           &&
	acc(&d.running)           &&
	acc(&d.Metrics)           &&
	acc(&d.forwardingMetrics) &&
	(d.external    != nil       ==> AccBatchConn(d.external))         &&
	(d.linkTypes   != nil       ==> acc(d.linkTypes))                 &&
	(d.neighborIAs != nil       ==> acc(d.neighborIAs))               &&
	(d.internal != nil          ==> d.internal.Mem())                 &&
	(d.internalIP != nil        ==> d.internalIP.Mem())               &&
	(d.internalNextHops != nil  ==> AccAddr(d.internalNextHops))      &&
	(d.svc != nil               ==> d.svc.Mem())                      &&
	// TODO: replace when I know the exact spec that macFactory should implement
	(d.macFactory != nil        ==> false)                            &&
	(d.bfdSessions != nil       ==> AccBfdSession(d.bfdSessions))     &&
	(d.Metrics != nil           ==> d.Metrics.Mem())                  &&
	// TODO: forwading metrics
	(d.forwardingMetrics != nil ==> false)
}

pred AccAddr(addrs map[uint16]*net.UDPAddr) {
	acc(addrs) &&
	forall a *net.UDPAddr :: a in range(addrs) ==> a.Mem()
}

pred AccBatchConn(batchConns map[uint16]BatchConn) {
	acc(batchConns) &&
	forall b BatchConn :: b in range(batchConns) ==> b.Mem()
}

pred AccBfdSession(bfdSessions map[uint16]bfdSession) {
	acc(bfdSessions) &&
	forall bfd bfdSession :: bfd in range(bfdSessions) ==> bfd.Mem()
}