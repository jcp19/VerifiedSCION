// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package router

import (
	"net"
	"hash"
	sl "github.com/scionproto/scion/verification/utils/slices"
	"github.com/scionproto/scion/pkg/scrypto"
	"github.com/scionproto/scion/pkg/addr"
)

// TODO: drop this predicate
pred (d *DataPlane) MacFactoryOperational(key *[]byte) {
	acc(&d.macFactory, 1/2) &&
	acc(key) &&
	acc(sl.AbsSlice_Bytes(*key, 0, len(*key)), _) &&
	scrypto.ValidKeyForHash(*key) &&
	d.macFactory implements MacFactorySpec{key}
}

ghost const (
	MutexInvariantPerm perm = 1/2
	MemPerm perm = 1/2
)

pred MutexInvariant(d *DataPlane) {
	// access to the field 'mtx' ommited
	acc(&d.external,          MutexInvariantPerm) &&
	acc(&d.linkTypes,         MutexInvariantPerm) &&
	acc(&d.neighborIAs,       MutexInvariantPerm) &&
	acc(&d.internal,          MutexInvariantPerm) &&
	acc(&d.internalIP,        MutexInvariantPerm) &&
	acc(&d.internalNextHops,  MutexInvariantPerm) &&
	acc(&d.svc,               MutexInvariantPerm) &&
	acc(&d.macFactory,        MutexInvariantPerm) &&
	acc(&d.bfdSessions,       MutexInvariantPerm) &&
	acc(&d.localIA,           MutexInvariantPerm) &&
	acc(&d.running,           MutexInvariantPerm) &&
	acc(&d.Metrics,           MutexInvariantPerm) &&
	acc(&d.forwardingMetrics, MutexInvariantPerm)
}

pred (d *DataPlane) Mem(key *[]byte) {
	acc(&d.external,          MemPerm) &&
	acc(&d.linkTypes,         MemPerm) &&
	acc(&d.neighborIAs,       MemPerm) &&
	acc(&d.internal,          MemPerm) &&
	acc(&d.internalIP,        MemPerm) &&
	acc(&d.internalNextHops,  MemPerm) &&
	acc(&d.svc,               MemPerm) &&
	acc(&d.macFactory,        MemPerm) &&
	acc(&d.bfdSessions,       MemPerm) &&
	acc(&d.localIA,           MemPerm) &&
	acc(&d.running,           MemPerm) &&
	acc(&d.Metrics,           MemPerm) &&
	acc(&d.forwardingMetrics, MemPerm) &&
	//
	(key == nil ==> d.macFactory == nil) &&
	// TODO: simplify the following garbage
	// TODO: move this to d.Mem(...) and drop all (now unnecessary) wildcards
	// TODO: the transformations from --conditionalizeBranches myself
	(d.external    != nil       ==> AccBatchConn(d.external))           &&
	(d.linkTypes   != nil       ==> acc(d.linkTypes))                   &&
	(d.neighborIAs != nil       ==> acc(d.neighborIAs))                 &&
	(d.internal != nil          ==> d.internal.Mem())                   &&
	(d.internalIP != nil        ==> d.internalIP.Mem())                 &&
	(d.internalNextHops != nil  ==> AccAddr(d.internalNextHops))        &&
	(d.svc != nil               ==> d.svc.Mem())                        &&
	// the following overlaps with MacFactoryOperational
	(key           != nil       ==> (
		acc(key)                                      &&
		acc(sl.AbsSlice_Bytes(*key, 0, len(*key)), _) &&
		scrypto.ValidKeyForHash(*key)                 &&
		d.macFactory implements MacFactorySpec{key}))                   &&
	(d.bfdSessions != nil       ==> AccBfdSession(d.bfdSessions))       &&
	(d.Metrics != nil           ==> d.Metrics.Mem())                    &&
	// The following permissions are enough to call all methods needed in fields
	// of forwardingMetrics
	(d.forwardingMetrics != nil ==> AccForwardingMetrics(d.forwardingMetrics))
}

ghost
pure
requires acc(d.Mem(key), _)
decreases
func (d *DataPlane) AlreadyRegisteredExternalInterface(ifID uint16, key *[]byte) bool {
	return unfolding acc(d.Mem(key), _) in (d.external != nil? (unfolding acc(AccBatchConn(d.external), _) in (ifID in domain(d.external))) : false)
}

ghost
pure
requires acc(d.Mem(key), _)
decreases
func (d *DataPlane) IA(key *[]byte) addr.IA {
	return unfolding acc(d.Mem(key), _) in d.localIA
}

ghost
pure
requires acc(d.Mem(key), _)
decreases
func (d *DataPlane) IsRunning(key *[]byte) bool {
	return unfolding acc(d.Mem(key), _) in d.running
}

ghost
pure
requires acc(d.Mem(key), _)
decreases
func (d *DataPlane) RegisteredIfcNeighborIA(key *[]byte) set[uint16] {
	return unfolding acc(d.Mem(key), _) in domain(d.neighborIAs)
}

ghost
pure
requires acc(d.Mem(key), _)
decreases
func (d *DataPlane) RegisteredIfcLinkType(key *[]byte) set[uint16] {
	return unfolding acc(d.Mem(key), _) in domain(d.linkTypes)
}

// TODO: use lower case for these predicates' names?
pred AccAddr(addrs map[uint16]*net.UDPAddr) {
	acc(addrs) &&
	forall a *net.UDPAddr :: a in range(addrs) ==> a.Mem()
}

pred AccBatchConn(batchConns map[uint16]BatchConn) {
	acc(batchConns) &&
	forall b BatchConn :: { b in range(batchConns) } b in range(batchConns) ==> b.Mem()
}

pred AccBfdSession(bfdSessions map[uint16]bfdSession) {
	acc(bfdSessions) &&
	forall bfd bfdSession :: bfd in range(bfdSessions) ==> bfd != nil && acc(bfd.Mem(), _)
}

pred AccForwardingMetrics(metrics map[uint16]forwardingMetrics) {
	acc(metrics) &&
	forall id uint16 :: { metrics[id] } id in domain(metrics) ==> forwardingMetricsMem(metrics[id], id)
}

pred forwardingMetricsMem(v forwardingMetrics, ignoredForInjectivity uint16) {
	v.InputBytesTotal.Mem()      &&
	v.OutputBytesTotal.Mem()     &&
	v.InputPacketsTotal.Mem()    &&
	v.OutputPacketsTotal.Mem()   &&
	v.DroppedPacketsTotal.Mem()
}

pred forwardingMetricsNonInjectiveMem(v forwardingMetrics) {
	v.InputBytesTotal.Mem()      &&
	v.OutputBytesTotal.Mem()     &&
	v.InputPacketsTotal.Mem()    &&
	v.OutputPacketsTotal.Mem()   &&
	v.DroppedPacketsTotal.Mem()
}

ghost
requires  forwardingMetricsNonInjectiveMem(v)
ensures   forwardingMetricsMem(v, id)
decreases
func liftForwardingMetricsNonInjectiveMem(v forwardingMetrics, id uint16) {
	unfold forwardingMetricsNonInjectiveMem(v)
	fold forwardingMetricsMem(v, id)
}

pred (p *scionPacketProcessor) initMem() {
	acc(&p.d) &&
	acc(&p.ingressID) &&
	acc(&p.buffer) &&
	acc(&p.mac) &&
	acc(p.scionLayer.NonInitMem()) &&
	p.scionLayer.PathPoolInitializedNonInitMem() &&
	acc(&p.hbhLayer) &&
	acc(&p.e2eLayer) &&
	acc(&p.lastLayer) &&
	acc(&p.path) &&
	acc(&p.hopField) &&
	acc(&p.infoField) &&
	acc(&p.segmentChange) &&
	acc(&p.cachedMac) &&
	acc(&p.macBuffers) &&
	acc(&p.bfdLayer)
}

// TODO: simplify spec, re-do wildcard, maybe remove them
requires acc(key, _)
requires acc(sl.AbsSlice_Bytes(*key, 0, len(*key)), _)
requires scrypto.ValidKeyForHash(*key)
ensures  res.Mem()
decreases
func MacFactorySpec(ghost key *[]byte) (res hash.Hash)

pred (err scmpError) ErrorMem() {
	err.Cause != nil ==> err.Cause.ErrorMem()
}

// Currently assumed, as Gobra cannot currently prove termination
// of the code below
ghost
trusted
pure
decreases
func (err scmpError) IsDuplicableMem() bool {
	return err != nil? err.cause.IsDuplicableMem() : true
}

// Currently assumed, as Gobra cannot currently prove termination
// of the code below
ghost
trusted
preserves err.ErrorMem()
ensures   err.IsDuplicableMem() ==> err.ErrorMem()
decreases
func (err scmpError) Duplicate() {
	if err.IsDuplicableMem() {
		unfold err.ErrorMem()
		err.cause.Duplicate()
		fold err.ErrorMem()
	}
}

scmpError implements error

type offsetPair struct {
	start int
	end int
	isNil bool
}

ghost
pure
requires 0 <= n
ensures  len(res) == n
ensures  forall i int :: {res[i]} 0 <= i && i < len(res) ==> res[i] == offsetPair{}
decreases
func newOffsetPair(n int) (res seq[offsetPair])